(()=>{"use strict";var n={d:(o,e)=>{for(var i in e)n.o(e,i)&&!n.o(o,i)&&Object.defineProperty(o,i,{enumerable:!0,get:e[i]})},o:(n,o)=>Object.prototype.hasOwnProperty.call(n,o),r:n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}},o={};n.r(o),n.d(o,{clearQueries:()=>i,cquery_cache:()=>e,fetchJsonEngine:()=>a,invalidateQuery:()=>l,invokeSubscriptions:()=>r,mockEngine:()=>c,mockQuery:()=>s,preparedQuery:()=>t,replaceQuery:()=>u,replaceQueryDefaultEngine:()=>d,resetContext:()=>k,subscribeQuery:()=>g,useQuery:()=>f});const e={};function i(){for(var n in e)delete e[n]}function t(n,o,i={},t={}){if(n in e){let i=e[n];return void(i.url!==o&&console.warn(`ignore the url: a query already exists with different url ${i.url}, you try to prepare for ${o}`))}let l={callbacks:[],data:null,error:null,key:n,isLoading:!1,response:null,mock:!1,url:o,request_options:i,invalidationStop:null,invalidationInterval:null,invalidationCounter:0,postponeInvalidation:t.postponeInvalidation||!0,engine:t.engine||null,delayedLoading:!0};"delayedLoading"in t&&(l.delayedLoading=t.delayedLoading),"mock"in t&&null!==t.mock&&I(l,t),"interval"in t&&null!==t.interval&&L(l,t.interval),e[n]=l}function l(n){m(n);const o=e[n];null===o.data&&!0===o.isLoading||y(o,!0)}function r(n,o,e,i){if(n.invalidationCounter-=1,0===n.invalidationCounter||!1===n.postponeInvalidation){n.isLoading=!1,n.data=o,n.error=e,n.response=i;for(const o in n.callbacks)v(n.callbacks[o],n)}}function a(n){let o=null;fetch(n.url,n.request_options).then((n=>(o=n,n.json()))).then((e=>{r(n,e,null,o)})).catch((e=>{console.error(e),r(n,null,e,o)}))}function c(n){n.isLoading=n.mockIsLoading,r(n,n.mockData,n.mockError,n.mockResponse)}function s(n,o,i=!1,t=null,l=null){m(n);const r=e[n];r.mock=!0,r.mockData=o,r.mockIsLoading=i,r.mockError=t,r.mockResponse=l}function u(n,o,i={},t={}){m(n);let l=e[n];l.url=o,l.request_options=i,l.engine=t.engine||p,"mock"in t?I(l,t):function(n){n.mock=!1,n.mockData=null,n.mockIsLoading=null,n.mockError=null,n.mockResponse=null}(l),"interval"in t?L(l,t.interval):h(l)}function d(n){p=n}function k(){p=a,i()}function f(n,o){m(n);const i=e[n];null===i.data&&!1===i.isLoading&&null===i.error?(i.callbacks.push(o),y(i)):(i.callbacks.push(o),v(o,i))}function g(n,o){m(n);const i=e[n];null===i.data&&!1===i.isLoading&&null===i.error?i.callbacks.push(o):(i.callbacks.push(o),v(o,i))}let p=a;function m(n){if(!(n in e))throw`The query '${n}' does not exists - prepared queries : [${Object.keys(e)}]`}function y(n,o=!1){if(n.invalidationCounter+=1,!0!==n.mock){n.data=null,n.isLoading=!0,n.response=null,n.error=null;for(const o in n.callbacks)v(n.callbacks[o],n)}if(!0===n.mock&&!0===n.mockIsLoading){n.isLoading=n.mockIsLoading;for(const o in n.callbacks)b(n.callbacks[o],n)}else!0===n.mock?c(n):null!==n.engine?n.engine(n):p(n)}function v(n,o){let e=new _;try{n(o.data,o.isLoading,o.error,o.response,e)}catch(n){console.error(n)}!0===e.triggered&&S(o,n)}function b(n,o){let e=new _;try{n(o.mockData,o.mockIsLoading,o.mockError,o.mockResponse,e)}catch(n){console.error(n)}!0===e.triggered&&S(o,n)}function L(n,o){h(n),n.invalidationStop=setTimeout((()=>L(n,o)),1e3*o),!1!==n.isLoading&&!1!==n.delayedLoading||y(n)}function h(n){n.invalidationStop&&clearTimeout(n.invalidationStop)}function I(n,o){n.mock=!0,n.mockData=o.mock.data,n.mockIsLoading=o.mock.isLoading,n.mockError=o.mock.error,n.mockResponse=o.mock.response}function S(n,o){const e=n.callbacks.indexOf(o);-1!==e&&n.callbacks.splice(e,1)}function _(){this.triggered=!1,this.set=()=>{this.triggered=!0}}var w=window;for(var E in o)w[E]=o[E];o.__esModule&&Object.defineProperty(w,"__esModule",{value:!0})})();